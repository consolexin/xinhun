## 单层感知器实现逻辑或运算算法说明
### 学习算法如下
### 1，设置变量和参数
> - `x[4][3]=[1,x1,x2]`为输入向量，输入向量总共有4组分别为`(1,0,0),(1,0,1),(1,1,0),(1,1,1)`
> - `w[][3]=[sita,w1,w2]`为权值向量，其中`sita`为阈值，`w1，w2`为权值
> - `w[i][]`表示第`i`次循环时的权值向量
> - `y`为实际输出值
> - `d[4]`为期望输出值,`d[i]`表示输入向量为`x[i]`时的期望输出值
> - ` yita`为学习因子，为随机的`（0，100）`之间的整数
> -  `N`为迭代次数，宏定义为`1000000`

### 2，初始化
> -  给`w[0][3]`赋值一个随机的`（0，100）`之间的整数

### 3，判断当前的权值和阈值是否满足条件
```cpp
bool isOK(int i){
    for(int j=0;j<4;j++){
        double m=w[i][0]+w[i][1]*x[j][1]+w[i][2]*x[j][2];
        double y=(m>=0)?1:0;
        if(abs(y-d[j])>0.001) return false;
    }
    return true;
}
```
> - 如果能够满足条件，直接结束

### 4，计算当前权值和阈值的输出
> -  首先计算累加器的结果

```cpp
double m=w[i][0]+w[i][1]*x[i%4][1]+w[i][2]*x[i%4][2];
```
> -  再将累加器的结果传入二值函数中，就是当前权值和阈值的输出

```cpp
double y=(m>=0)?1:0;
```
### 5，调整感知器的权值向量
>  - 根据`w[n+1]=w[n]+`$\eta$`* (d[n]-y[n])*x[n]`调整

```cpp
for(int j=0;j<3;j++){
	w[i+1][j]=w[i][j]+yita*(d[i%4]-y)*x[i%4][j];
}
```
### 6，判断是否满足循环结束条件，即i是否大于等于N，满足则退出循环，不满足则回到第3步

### 7，输出结果
> -  一行包括四个值
> -  第一个值表示第几次找到了结果
> -  第二个值表示阈值$\theta$的值
> -  第三个值表示权值`w1`
> - 第四个值表示权值`w2`

# 运行方式
 在windows xp/xp+环境下，使用任意版本的dev c++ IDE 按`F11`可以输出结果，使用任意版本的codeblocks按`F9`可以输出结果

# 注意
 在以上的学习算法中，对于步骤3，判断是否满足条件，这里的条件可以是，期望值的误差减去实际值的误差，即$|d[n]-y[n]|<0.001$。另外在算法实现的过程中，设置了最大迭代次数为`1000000`，防止程序陷入死循环。本程序采用纠错学习规则对权值向量进行逐步修正，对于单层感知器实现逻辑或运算，这是线性可分的模式，这种学习算法是收敛的，即通过学习调整权值能够得出合适的边界

#### 作者 [@xinhun]
#### 2018年5月11日
[@xinhun]:#


